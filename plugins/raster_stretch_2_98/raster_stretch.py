# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RasterStretch
                                 A QGIS plugin
 This plugin visualizes the raster using 2-98 percentile (or custom)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-09-13
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Mikhail Sokolov
        email                : sokolov.usmk@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis._core import QgsRasterLayer, QgsRectangle, QgsRasterBandStats, QgsRasterHistogram, QgsContrastEnhancement, \
    QgsSingleBandGrayRenderer
from qgis.core import QgsProject
from qgis.core import Qgis
import os
# Initialize Qt resources from file resources.py
# from .resources import *
# Import the code for the DockWidget
# from .raster_stretch_dockwidget import RasterStretchDockWidget

try:
    from .resources import *
    from .raster_stretch_dockwidget import RasterStretchDockWidget
except ImportError:
    import os, sys
    sys.path.append(os.path.dirname(__file__))
    from raster_stretch_dockwidget import RasterStretchDockWidget
    from resources import *

import os.path


def _percentile_from_hist(provider, band, lower_pct, upper_pct, extent=None, bins=256):
    """Calculate lower and upper percentile values from raster histogram.

    :param provider: raster data provider
    :type provider: QgsRasterDataProvider
    :param band: band number (1-based)
    :type band: int
    :param lower_pct: lower percentile (0-100)
    :type lower_pct: float
    :param upper_pct: upper percentile (0-100)
    :type upper_pct: float
    :param extent: optional extent to limit calculation
    :type extent: QgsRectangle or None
    :param bins: number of histogram bins (default 256)
    :type bins: int

    :returns: (lower_value, upper_value) tuple corresponding to the percentiles
    :rtype: (float, float)
    """
    if extent is None:
        extent = QgsRectangle()

    stats = provider.bandStatistics(band, QgsRasterBandStats.Min | QgsRasterBandStats.Max, extent, 0)
    if stats is None or stats.minimumValue is None or stats.maximumValue is None:
        return None, None

    minval = stats.minimumValue
    maxval = stats.maximumValue
    if not (minval < maxval):
        return None, None

    h = provider.histogram(band, bins, minval, maxval, extent)
    if not isinstance(h, QgsRasterHistogram):
        return None, None

    counts = list(h.histogramVector) if hasattr(h, 'histogramVector') else None
    if counts is None or len(counts) != bins:
        return None, None

    total = sum(counts)
    if total <= 0:
        return None, None

    # acc
    acc = 0
    lower_threshold = total * (lower_pct / 100.0)
    upper_threshold = total * (upper_pct / 100.0)

    low_bin = 0
    high_bin = len(counts) - 1

    for i, count in enumerate(counts):
        acc += count
        if acc >= lower_threshold:
            low_bin = i
            break
    acc2 = 0
    for i in range(len(counts) - 1, -1, -1):
        acc2 += counts[i]
        if acc2 >= (total - upper_threshold):
            high_bin = i
            break

    bin_width = (maxval - minval) / float(len(counts))
    lower_value = minval + bin_width * low_bin
    upper_value = minval + bin_width * (high_bin + 1)

    if lower_value >= upper_value:
        return None, None

    return lower_value, upper_value


class RasterStretch:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RasterStretch_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&RasterStretch')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'RasterStretch')
        self.toolbar.setObjectName(u'RasterStretch')

        #print "** INITIALIZING RasterStretch"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RasterStretch', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/raster_stretch/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Raster Stretch'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING RasterStretch"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD RasterStretch"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&RasterStretch'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = RasterStretchDockWidget()

                self.iface.messageBar().pushMessage("RasterStretch", f"PLUGIN DIR: {os.path.dirname(__file__)}", level=Qgis.Info, duration=3)

                self._connect_project_signals()
                self._refresh_raster_combo()
                self.dockwidget.comboBox.currentIndexChanged.connect(self._on_raster_selected)
                self.dockwidget.Apply.clicked.connect(self._on_apply_clicked)

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

    def _on_apply_clicked(self):
        """Apply stretch to the selected raster layer."""
        current_min = self.dockwidget.minPercVal.value()
        current_max = self.dockwidget.maxPercVal.value()
        use_canvas_extent: bool = False
        lyr = self._selected_layer()
        if lyr is None:
            return
        extent = (self.iface.mapCanvas().extent() if use_canvas_extent else lyr.extent())

        min_val, max_val = _percentile_from_hist(
            self._selected_layer().dataProvider(),
            1,
            float(current_min),
            float(current_max),
            extent,
            256)

        prov = lyr.dataProvider()
        raw_dtype = prov.dataType(1)
        try:
            qdtype = Qgis.DataType(raw_dtype)  # works when underlying value maps 1:1
        except Exception:
            # Safe fallback if mapping ever fails
            qdtype = Qgis.DataType.Float32

        ce = QgsContrastEnhancement(qdtype)
        ce.setMinimumValue(min_val)
        ce.setMaximumValue(max_val)
        ce.setContrastEnhancementAlgorithm(
            QgsContrastEnhancement.StretchToMinimumMaximum, True)

        renderer = QgsSingleBandGrayRenderer(prov, 1)
        lyr.setRenderer(renderer)
        lyr.triggerRepaint()

    def _selected_layer(self) -> QgsRasterLayer | None:
        cb = self.dockwidget.comboBox
        layer_id = cb.itemData(cb.currentIndex())
        if not layer_id:
            return None
        lyr = QgsProject.instance().mapLayer(layer_id)
        return lyr if isinstance(lyr, QgsRasterLayer) else None

    def _on_raster_selected(self, _):
        lyr = self._selected_layer()
        stats = lyr.dataProvider().bandStatistics(1, QgsRasterBandStats.Min | QgsRasterBandStats.Max, QgsRectangle(), 1000)
        self.dockwidget.minValText.setText(str(stats.minimumValue))
        self.dockwidget.maxValText.setText(str(stats.maximumValue))


    def _refresh_raster_combo(self):
        """Rebuild combo items from all raster layers in the current project."""
        cb = self.dockwidget.comboBox  # 9) get a handle to your combo

        cb.blockSignals(True)  # 10) prevent firing currentIndexChanged while we rebuild
        cb.clear()  # 11) start from an empty combo

        # 12) Iterate all layers registered in the project
        for lyr in QgsProject.instance().mapLayers().values():
            # 13) Keep only rasters and ensure the layer is valid
            if isinstance(lyr, QgsRasterLayer) and lyr.isValid():
                # 14) Visible text is the layer name; userData stores the layer ID (stable & unique)
                cb.addItem(lyr.name(), lyr.id())

        cb.blockSignals(False)  # 15) re-enable signals after rebuilding


    def _on_layers_changed(self, *args):
        self._refresh_raster_combo()

    def _connect_project_signals(self):
        prj = QgsProject.instance()
        prj.layersAdded.connect(self._on_layers_changed)
        prj.layersRemoved.connect(self._on_layers_changed)
        prj.cleared.connect(self._refresh_raster_combo)
        prj.readProject.connect(self._refresh_raster_combo)
