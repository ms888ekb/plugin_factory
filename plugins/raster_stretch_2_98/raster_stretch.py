# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RasterStretch
                                 A QGIS plugin
 This plugin visualizes the raster using 2-98 percentile (or custom)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-09-13
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Mikhail Sokolov
        email                : sokolov.usmk@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis._core import QgsRasterLayer, QgsRectangle, QgsRasterBandStats, QgsRasterHistogram, QgsContrastEnhancement, \
    QgsSingleBandGrayRenderer, QgsMultiBandColorRenderer, QgsRasterRenderer, QgsMapLayer, \
    QgsSingleBandPseudoColorRenderer, QgsRasterRange
from qgis.core import QgsProject
from qgis.core import Qgis
import os
# Initialize Qt resources from file resources.py
# from .resources import *
# Import the code for the DockWidget
# from .raster_stretch_dockwidget import RasterStretchDockWidget

try:
    from .resources import *
    from .raster_stretch_dockwidget import RasterStretchDockWidget
except ImportError:
    import os, sys
    sys.path.append(os.path.dirname(__file__))
    from raster_stretch_dockwidget import RasterStretchDockWidget
    from resources import *

import os.path


class RasterStretch:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RasterStretch_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&RasterStretch')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'RasterStretch')
        self.toolbar.setObjectName(u'RasterStretch')

        #print "** INITIALIZING RasterStretch"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RasterStretch', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/raster_stretch/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Raster Stretch'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING RasterStretch"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD RasterStretch"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&RasterStretch'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------
    def _percentile_from_hist(self, provider, band, lower_pct, upper_pct, extent=None, bins=256):
        """Calculate lower and upper percentile values from raster histogram.

        :param provider: raster data provider
        :type provider: QgsRasterDataProvider
        :param band: band number (1-based)
        :type band: int
        :param lower_pct: lower percentile (0-100)
        :type lower_pct: float
        :param upper_pct: upper percentile (0-100)
        :type upper_pct: float
        :param extent: optional extent to limit calculation
        :type extent: QgsRectangle or None
        :param bins: number of histogram bins (default 256)
        :type bins: int

        :returns: (lower_value, upper_value) tuple corresponding to the percentiles
        :rtype: (float, float)
        """
        if extent is None:
            extent = QgsRectangle()

        # Check if raster has assigned nodata value:
        provider.reload()
        user_rng = provider.userNoDataValues(band)

        #
        # if nodata is not None:
        #     self.iface.messageBar().pushMessage("RasterStretch", f"Raster has NoData value: {nodata}", level=Qgis.Info, duration=3)
        #     rng = QgsRasterRange(nodata, nodata)

        if self.dockwidget.lineEditNoData.isEnabled():
            try:
                nodata_val = float(self.dockwidget.lineEditNoData.text())
            except ValueError:
                nodata_val = None

            if nodata_val is not None:
                self.iface.messageBar().pushMessage("RasterStretch", f"Setting NoData value: {nodata_val}", level=Qgis.Info, duration=3)
                rng = [QgsRasterRange(nodata_val, nodata_val)]
            else:
                self.iface.messageBar().pushMessage("RasterStretch", f"Clear NoData value", level=Qgis.Info, duration=3)
                rng = [QgsRasterRange()]

            provider.setUserNoDataValue(band, rng)
        self.iface.messageBar().pushMessage("dbg",
                                            f"user ranges={provider.userNoDataValues(band)}, "
                                            f"sourceHasND={provider.sourceHasNoDataValue(band)}, "
                                            f"sourceND={provider.sourceNoDataValue(band)}",
                                            level=Qgis.Info, duration=4)
        stats = provider.bandStatistics(band, QgsRasterBandStats.Min | QgsRasterBandStats.Max, extent, 0)
        if stats is None or stats.minimumValue is None or stats.maximumValue is None:
            return None, None

        minval = stats.minimumValue
        maxval = stats.maximumValue
        self.iface.messageBar().pushMessage("RasterStretch", f"Band stats: min={minval}, max={maxval}", level=Qgis.Warning, duration=3)

        if minval > maxval:
            return None, None

        h = provider.histogram(band, bins, minval, maxval, extent)

        if not isinstance(h, QgsRasterHistogram):
            return None, None

        counts = list(h.histogramVector) if hasattr(h, 'histogramVector') else None
        if counts is None or len(counts) != bins:
            return None, None

        total = sum(counts)
        if total <= 0:
            return None, None

        # acc
        acc = 0
        lower_threshold = total * (lower_pct / 100.0)
        upper_threshold = total * (upper_pct / 100.0)

        low_bin = 0
        high_bin = len(counts) - 1

        for i, count in enumerate(counts):
            acc += count
            if acc >= lower_threshold:
                low_bin = i
                break
        acc2 = 0
        for i in range(len(counts) - 1, -1, -1):
            acc2 += counts[i]
            if acc2 >= (total - upper_threshold):
                high_bin = i
                break

        bin_width = (maxval - minval) / float(len(counts))
        lower_value = minval + bin_width * low_bin
        upper_value = minval + bin_width * (high_bin + 1)

        if lower_value >= upper_value:
            return None, None

        if self.dockwidget.lineEditNoData.isEnabled():
            provider.setUserNoDataValue(band, user_rng)
            provider.reload()

        return lower_value, upper_value

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = RasterStretchDockWidget()
                self._connect_project_signals()
                self._refresh_raster_combo()
                self.dockwidget.comboBox.currentIndexChanged.connect(self._on_raster_selected)
                self.dockwidget.Apply.clicked.connect(self._on_apply_clicked)
                self.dockwidget.checkBoxNoData.stateChanged.connect(self._on_nodata_checked)

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

    def _on_nodata_checked(self, state):
        """Handle NoData checkbox state change."""
        checkBox = self.dockwidget.checkBoxNoData
        if state == Qt.Checked:
            # Enable lineEditNoData:
            self.dockwidget.lineEditNoData.setEnabled(True)
        else:
            self.dockwidget.lineEditNoData.setEnabled(False)
        return

    def _on_apply_clicked(self):
        """Apply stretch to the selected raster layer."""
        current_min = self.dockwidget.minPercVal.value()
        current_max = self.dockwidget.maxPercVal.value()
        use_canvas_extent: bool = False
        lyr = self._selected_layer()
        if lyr is None:
            return
        renderer = lyr.renderer()
        provider = lyr.dataProvider()
        extent = (self.iface.mapCanvas().extent() if use_canvas_extent else lyr.extent())

        if isinstance(renderer, QgsSingleBandGrayRenderer):
            band = renderer.grayBand() or 1
            min_val, max_val = self._percentile_from_hist(
                provider=provider,
                band=band,
                lower_pct=float(current_min),
                upper_pct=float(current_max),
                extent=extent,
                bins=512)

            if min_val is None or max_val is None:
                self.iface.messageBar().pushMessage("RasterStretch", "Failed to compute percentiles", level=Qgis.Warning, duration=4)
                self.iface.messageBar().pushMessage("RasterStretch", f"min_val={min_val}, max_val={max_val}",
                                                    level=Qgis.Info, duration=4)
                return

            raw_dtype = provider.dataType(band)
            ce = QgsContrastEnhancement(raw_dtype)
            ce.setMinimumValue(min_val)
            ce.setMaximumValue(max_val)
            ce.setContrastEnhancementAlgorithm(
            QgsContrastEnhancement.StretchToMinimumMaximum, True)
            renderer.setContrastEnhancement(ce)

            lyr.setRenderer(renderer.clone())
            lyr.triggerRepaint()
            self.iface.messageBar().pushMessage(f"RasterStretch",
                                                f"Applied stretch: {current_min:.1f} - {current_max:.1f} percentile",
                                                level=Qgis.Success,
                                                duration=4)
            return

        if isinstance(renderer, QgsMultiBandColorRenderer):
            rb, gb, bb = renderer.redBand(), renderer.greenBand(), renderer.blueBand()
            for band, setter in [
                (rb, getattr(renderer, "setRedContrastEnhancement", None)),
                (gb, getattr(renderer, "setGreenContrastEnhancement", None)),
                (bb, getattr(renderer, "setBlueContrastEnhancement", None))
            ]:
                if band:
                    min_val, max_val = self._percentile_from_hist(
                        provider=provider,
                        band=band,
                        lower_pct=float(current_min),
                        upper_pct=float(current_max),
                        extent=extent,
                        bins=512)

                    if min_val is None or max_val is None:
                        self.iface.messageBar().pushMessage("RasterStretch", f"Failed to compute percentiles for band {band}", level=Qgis.Warning, duration=4)
                        return

                    raw_dtype = provider.dataType(band)
                    ce = QgsContrastEnhancement(raw_dtype)
                    ce.setMinimumValue(min_val)
                    ce.setMaximumValue(max_val)
                    ce.setContrastEnhancementAlgorithm(
                        QgsContrastEnhancement.StretchToMinimumMaximum, True)
                    if callable(setter):
                        setter(ce)
            lyr.setRenderer(renderer.clone())
            lyr.triggerRepaint()
            self.iface.messageBar().pushMessage(f"RasterStretch",
                                                f"Applied stretch: {current_min:.1f} - {current_max:.1f} percentile",
                                                level=Qgis.Success,
                                                duration=4)
            return

        if isinstance(renderer, QgsSingleBandPseudoColorRenderer) or isinstance(renderer, QgsRasterRenderer):
            band = 1
            min_val, max_val = self._percentile_from_hist(
                provider=provider,
                band=band,
                lower_pct=float(current_min),
                upper_pct=float(current_max),
                extent=extent,
                bins=512)
            if min_val is None or max_val is None:
                self.iface.messageBar().pushMessage("RasterStretch", "Failed to compute percentiles", level=Qgis.Warning, duration=4)
                return

            raw_dtype = provider.dataType(band)
            ce = QgsContrastEnhancement(raw_dtype)
            ce.setMinimumValue(min_val)
            ce.setMaximumValue(max_val)
            ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum, True)

            new_renderer = QgsSingleBandGrayRenderer(provider, band)
            new_renderer.setContrastEnhancement(ce)

            lyr.setRenderer(new_renderer)
            lyr.triggerRepaint()
            self.iface.messageBar().pushMessage(f"RasterStretch",
                                                f"Applied stretch: {current_min:.1f} - {current_max:.1f} percentile",
                                                level=Qgis.Success,
                                                duration=4)
            return

        self.iface.messageBar().pushMessage("RasterStretch",
                                            "Unsupported raster renderer type",
                                            level=Qgis.Warning, duration=4)


    def _selected_layer(self) -> QgsRasterLayer | None:
        cb = self.dockwidget.comboBox
        layer_id = cb.itemData(cb.currentIndex())
        if not layer_id:
            return None
        lyr = QgsProject.instance().mapLayer(layer_id)
        return lyr if isinstance(lyr, QgsRasterLayer) else None

    def _on_raster_selected(self, _):
        lyr = self._selected_layer()

        # Check that dataProvider has a nodata value for each band:
        if lyr is not None:
            provider = lyr.dataProvider()
            if provider is not None:
                band_count = provider.bandCount()
                nodata_values = []
                for band in range(1, band_count + 1):
                    nodata = provider.sourceNoDataValue(band)
                    nodata_values.append(nodata)
                if all(n is not None for n in nodata_values):
                    # All bands have a nodata value
                    if len(set(nodata_values)) == 1:
                        self.dockwidget.nodataText.setText(f"nodata value found: {nodata_values[0]}")
                    else:
                         self.dockwidget.nodataText.setText(f"nodata values found (per band): {nodata_values}")
                elif all(n is None for n in nodata_values):
                    # No bands have a nodata value
                    self.dockwidget.nodataText.setText("no nodata value found")
                else:
                    self.dockwidget.nodataText.setText(f"nodata values found (per band): {nodata_values}")
        return


    def _refresh_raster_combo(self):
        """Rebuild combo items from all raster layers in the current project."""
        cb = self.dockwidget.comboBox  # 9) get a handle to your combo

        cb.blockSignals(True)  # 10) prevent firing currentIndexChanged while we rebuild
        cb.clear()  # 11) start from an empty combo

        # 12) Iterate all layers registered in the project
        for lyr in QgsProject.instance().mapLayers().values():
            # 13) Keep only rasters and ensure the layer is valid
            if isinstance(lyr, QgsRasterLayer) and lyr.isValid():
                # 14) Visible text is the layer name; userData stores the layer ID (stable & unique)
                cb.addItem(lyr.name(), lyr.id())

        cb.blockSignals(False)  # 15) re-enable signals after rebuilding


    def _on_layers_changed(self, *args):
        self._refresh_raster_combo()

    def _connect_project_signals(self):
        prj = QgsProject.instance()
        prj.layersAdded.connect(self._on_layers_changed)
        prj.layersRemoved.connect(self._on_layers_changed)
        prj.cleared.connect(self._refresh_raster_combo)
        prj.readProject.connect(self._refresh_raster_combo)
